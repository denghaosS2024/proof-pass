// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package email_credentials

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrUpdateOne = `-- name: CreateOrUpdateOne :one
INSERT INTO email_credentials (
        id,
        identity_commitment,
        data,
        issued_at,
        expire_at
    )
VALUES ($1, $2, $3, $4, $5) ON CONFLICT (identity_commitment) DO
UPDATE
SET data = $3,
    issued_at = $4,
    expire_at = $5
RETURNING id, identity_commitment, data, issued_at, expire_at
`

type CreateOrUpdateOneParams struct {
	ID                 string
	IdentityCommitment string
	Data               string
	IssuedAt           pgtype.Timestamptz
	ExpireAt           pgtype.Timestamptz
}

func (q *Queries) CreateOrUpdateOne(ctx context.Context, arg CreateOrUpdateOneParams) (EmailCredential, error) {
	row := q.db.QueryRow(ctx, createOrUpdateOne,
		arg.ID,
		arg.IdentityCommitment,
		arg.Data,
		arg.IssuedAt,
		arg.ExpireAt,
	)
	var i EmailCredential
	err := row.Scan(
		&i.ID,
		&i.IdentityCommitment,
		&i.Data,
		&i.IssuedAt,
		&i.ExpireAt,
	)
	return i, err
}

const getByIdentityCommitment = `-- name: GetByIdentityCommitment :one
SELECT id, identity_commitment, data, issued_at, expire_at
FROM email_credentials
WHERE identity_commitment = $1
LIMIT 1
`

func (q *Queries) GetByIdentityCommitment(ctx context.Context, identityCommitment string) (EmailCredential, error) {
	row := q.db.QueryRow(ctx, getByIdentityCommitment, identityCommitment)
	var i EmailCredential
	err := row.Scan(
		&i.ID,
		&i.IdentityCommitment,
		&i.Data,
		&i.IssuedAt,
		&i.ExpireAt,
	)
	return i, err
}
